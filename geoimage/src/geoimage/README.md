# Geoimage
##### A Javascript library for rendering bitmaps and terrain out of **geoTIFF** files.
<img src = "/images/example0crop1.png" width = "100%">

### Features
##### Color texture generation
- Create RGB pictures out of RGB geoTIFF data.
- Generate pictures out of non-RGB geoTIFF data with different processing options.

##### Terrain texture generation
- Generate heightmaps out of single-channel geoTIFF elevation data.
- Create tiled mesh layer which represents height values fron geoTIFF without any compression to height PNG. 
- Created mesh is TIN generated by [martini algorithm](https://github.com/mapbox/martini).


##### Data visualisation options
- Color
- Transparency
- Heatmap (custom color scale example [here](../cogbitmaplayer/README.md#custom-heatmap-color-scale))
- Data slice
- Automatic data range
- Manual data range
- Assign color to specific data value (example [here](../cogbitmaplayer/README.md#assigning-color-to-specific-data-value))

### Data processing options
- `useAutoRange : boolean` - set automatic range of color gradient **(default false)**
- `useDataForOpacity : boolean` - visualise data with opacity of each pixel according to its value **(default false)**
- `alpha : number` - visualise entire image with specified opacity **(if useDataOpacity is false)**, values 0-100 **(default 100)**
- `useHeatMap : boolean` - generate data as a color heatmap **(default true)**
 `useChannel : number | null` - specify a single channel to use **(default null)**
- `multiplier : number  ` - multiplies each value **(default 1.00)**
- `clipLow : number | null`- generate only data greater than this **(default null)**

- `clipHigh : number | null`- generate only data less than this **(default null)**
- `clippedColor: chroma.Color` - set color for clipped values when using `clipLow` or `clipHigh`, **(default [0, 0, 0, 0])**
- `colorScale:chroma.Color[]` - array of colors, supports chroma.js color definition (more below)
- `colorScaleValueRange: number[]` - set min and max range values or set any array of values to set exact colors to values, **if useAutoRange is false**, **(default [0,255])**
- `useColorsBasedOnValues: boolean` - assign pixels colors based on defined data values **(default false)**
- `colorsBasedOnValues : [number, chroma.Color][]` - array of value-color pairs, used **if useColorsBasedOnValues is true**, supports chroma.js color definition such as `'red'`, `[255,0,0]`, `'#FF0000'`, etc.
- `useColorClasses: boolean` - determines whether pixel colors are assigned based on predefined data classes (intervals) **(default false)**
- `colorClasses : [chroma.Color, [number, number], [boolean, boolean]?][]` - array of color-interval(-intervalBounds) triples, where the color is defined as chroma.js color; interval is defined as [min, max] array; and optional inteval bound as [boolean, boolean] array (default is [true, false] for all intervals except the last one which is [false, true]; used **if useColorClasses is true**, the values that don't belong to any interval are visualized as `unidentifiedColor`
- `unidentifiedColor: chroma.Color` - set color for not identified values **if useColorsBasedOnValues or useColorClasses is true**, **(default [0, 0, 0, 0])**
- `nullColor : chroma.Color` - set color for noData values **(default [0, 0, 0, 0])**
- `useSingleColor : boolean` - display data values only with single color **(default false)**
- `color : chroma.Color` - set color when **if useSingleColor is true**, **(default [255, 0, 255, 255])**
- `blurredTexture : boolean` - define blurring behaviour for textures when zoomed in = magnification filter parameter (`gl.TEXTURE_MAG_FILTER`). Default is `true` for blurry textures (corresponds to `GL.LINEAR`), to not blur textures use `false` (corresponds to `GL.NEAREST`)

#### Chroma.Color definition
Type `chroma.Color` means any color definition that is supported by chroma.js such as `'red'`, `[255,0,0]`, `[255,0,0, 180]`, `'#FF0000'`, 
etc. and [Color Brewer pallete names](https://www.datanovia.com/en/wp-content/uploads/dn-tutorials/ggplot2/figures/0101-rcolorbrewer-palette-rcolorbrewer-palettes-colorblind-friendly-1.png) 
in this format: `chroma.brewer.Greens`

#### Additional terrain processing options
- `terrainMinValue: number` - noData value retrieved from input file's metadata is substitute by this value **(default 0)**
- `terrainSkirtHeight: number` - defines height of individual tiles edges, so there are no white spaces between individual 3D tiles **(default 100)**

[//]: # (- `terrainColor: chroma.Color` - color of terrain model **&#40;default [133, 133, 133, 255]&#41;**)

- Setting **opacity for terrain layers**: Terrayin layer is ordinary Deck.gl layer instance, so opacity is common prop.

### Return options
**Method returns Image DataUrl**

- `getMap(returnFormat : "image" | "terrain", input : string | { width : number, height : number, rasters : any[] }, options?: { opacity : number })`

  If `returnFormat` = `"image"` - If the input has 3 or 4 color channels, return standard RGB or RGBA image. If the input has 1 channel, data gets processed according to data processing options.

  If `returnFormat` = `"terrain"` - Ignores all options except `multiplier` and returns  [Mapbox Terrain-RGB](https://docs.mapbox.com/data/tilesets/guides/access-elevation-data/#decode-data)

### Basic example
##### Initialize the library
```typescript
import GeoImage from 'geoimage';

const g = new GeoImage();
```
##### Get bitmap
```typescript
const bitmap = await g.getMap("image", 'image.tif');
```
```typescript
const bitmap = await g.getMap("image", { width : 512, height : 512, rasters : [[...data]] });
```



##### Get heightmap

```typescript
const heightmap = await g.getMap("terrain", 'image.tif');
```
```typescript
const bitmap = await g.getMap("terrain", { width : 512, height : 512, rasters : [[...data]] });
```

### Advanced example

```typescript
//Import the library and initiate GeoImage object:
import GeoImage from 'geoimage';

const g = new GeoImage();

//Single-channel geotiff as a transparent heatmap with auto-rage:
g.useAutoRange(true);
g.useHeatMap(true);
g.alpha(100);
const firstImage = await g.getMap("image", 'image.tif');

//Single-channel geotiff as a transparent heatmap with manual range in meters:
g.useAutoRange(false);
g.useDataRange(0,250); //Blue at 0m, red at 250m
g.useHeatMap(true);
g.alpha(80);
const secondImage = await g.getBitmap("image", 'image.tif');

//Single-channel geotiff with data as transparency:
g.useAutoRange(true);
g.useHeatMap(false);
g.useDataForOpacity(true);
const thirdImage = await g.getBitmap("image", 'image.tif');

//Single-channel geotiff with data slice from 350m to 360m in custom color:
g.clipLow(350); //generate only data between 350m and 360m
g.clipHigh(360); 
g.useHeatMap(false);
g.color[0,255,100];
const fourthImage = await g.getBitmap("image", 'image.tif');
```
